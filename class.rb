# クラス定義の例

class Foo
  def initialize(a)
    @a = a
  end
  def method1
    @a
  end
end

foo1 = Foo.new(1)
foo2 = Foo.new(2)

p foo1.method1 # => 1
p foo2.method1 # => 2

# クラス式
# クラス式は大文字で始めます。
---------------------------------------------------
# Rubyはクラスを提起するとき、次のように動作します。
# 1. 指定されたクラス名で定数を作成する。
# 2. 1の定数に、定義されたクラスを格納する。
---------------------------------------------------
# 「クラスを格納する」という表現については、Rubyにおいえtクラスはオブジェクトであり、
# 例のようにメソッドの実行や変数への再代入が可能です。

# クラスオブジェクトの操作
a = Foo # Fooの参照先を変数aに代入
a.new(1) # Fooを扱うのと同じように操作できる。
Foo = 1  # 定数なので警告が出る。

# class式が評価されると、クラス定義の内部が評価されることも覚えておきましょう。
# Rubyのクラス定義は、内部がスキップされることはなく順に評価されます。
# 実行すると、１から順に評価される。

# classの評価順序
p 1
class Hoge
  p 2
end
p 3
# 1, 2, 3の順に表示される。

# インスタンスメソッドと初期化メソッド
# 最初の例のmethod1の部分がインスタンスメソッドです。
# 他のメソッド同様にdefを使用します。クラスの内部に記述することで、そのクラスのインスタンスメソッドになります。

# initialzeというメソッドは特別で、初期化の時に実行されるメソッドです。

# ３行目と６行目の@aはインスタンス変数です。変数名の先頭に@をつけることで値がインスタンスに保持されます。

# 作成したクラスオブジェクトに対してnewメソッドを実行することで、インスタンスを生成できます。
# 例の２つのインスタンスfoo1とfoo2を生成して、それ俺定義したインスタンスメソッドを実行しています。
# newメソッドに渡した引数の値が異なるので、実行結果が変わっている点に注目してください。
# newメソッドの引数はそのまま初期化メソッドに渡されるため、@aは異なる値で初期化されます。

# classメソッド

foo1.class == Foo #=> true
# 上記では、foo1に対してclassメソッドを実行し、その結果がFooの参照先と一致しているかどうかを判定しています。
# foo1が指すオブジェクトはFooクラスのインスタンスなので、foo1.calssはFooが帰り、この判定式はtrueとなります。

# クラス継承
# 続いて継承したクラスを定義します。
# 以下はクラス継承の例です。

class FooExt < Foo
  def initialize(a,b)
    @b = b
    super a
  end
  def method2(c)
    @a + @b + c
  end
end

fooExt = FooExt.new(3,4)
p fooExt.method1 #=> 3
p fooExt.method2(5) #=> 12

# 上のコードはFooクラスを継承したFooExtクラスを定義しています。
# このようにclass定義において、「<」で区切ってクラスオブジェクトを指定すると、
# 指定したオブジェクトを継承したクラスオブジェクトを生成することができます。
# Fooクラスを継承しているので、p fooExt.method1のようにFooクラスで定義されたインスタンスメソッドのmethod1を実行することができます。

# 継承の方法を司会したところで、クラスオブジェクトからスーパークラスを取得する方法も復習します。
# これは以下のように、クラスオブジェクトに対してsuperclassメソッドを実行することで参照できます。

FooExt.superclass == Foo # => true

# super
# クラス定義のさいごにFooExtクラスを詳しく見る

# FooExtクラスには独自で定義した初期化メソッドと、method2を定義しています。
# 初期化めそっどでは、引数bの値をインスタンスに格納した上で、スーパークラスの初期化メソッドを呼び出しています。
# Fooクラスの初期化メソッドは引数で与えられた値を保持するので、
# 結果的にFooExtインスタンスは、初期化メソッドで引数で与えられた２つの値を保持します。

# スーパークラスの同名メソッドを呼び出す場合は、superを使います。
# superは、初期化メソッドに限らず任意のメソッドで使用できます。
# かっこと引数をつけずにsuperとすると、メソッドが受け取った引数を「そのまま」スーパークラスの同名メソッドに渡して実行します。

class Unko
  def initialize(kuso)
    @kuso = kuso
  end

  def unko1
    @kuso
  end
end

class HyperUnko < Unko
  def initialize
    super 
  end

  def unko2
    @kuso
  end
end