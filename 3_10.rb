# ブロックとProcオブジェクト
# ここまでリテラルを中心にRubyの基本を学んできましたが、Rubyの特徴の一つであるブロックについて学びます。
# まずはブロックとProcで、これは他のプログラミング言語ではクロージャに相当します。


# ブロックの基本
# for,if,whileなどは、スコープが作成されないことを見てきました。
# これに対して、ブロックは新たにスコープを作成するものだと考えてください。
# ブロックはメソッドを呼び出す時のみ記述でき、メソッドの内部では、yieldメソッドを使ってブロックを実行します。

# 使用例
def func
  x + yield # ブロックの実行結果を取得
end

p func(1) { 2 } # => 3: ブロック付きでメソッドを呼び出す

# {} に囲まれているのがブロックです。このブロックは２を返し、メソッドfuncではブロックの実行結果(yield)
# と引数の合計を返しているので、実行結果は３となります。

# ここまではC言語の関数へのポインタのように、単に処理をメソッドに渡しているだけのようにみえる。
# しかしブロックは、さらにスコープを生成するという特徴を持っています。

# スコープが生成されている様子
def func y
  y + yield
end

func(1) do
  x =2
end

p x # => NameError: undefined local variable or method `x' for main:Object

# 上の例では、ブロックの実行中に、ブロックの中で変数xに値を代入しています。
# これは下のスコープ（ブロックの外）とは別の場所に確保されるので、ブロックの外からは参照できません。
# また、ブロックは、波括弧{}だけでなく、do...endでも記述できます。

# ブロックにはもう一つ、重要な特徴があります。
# # 
# ブロックはスコープを生成するのに加えて、ブロック生成時の変数をブロック内で参照することができ、
# その変数を更新すると、結果が外部にも影響します。


# クロージャとしてのブロック
def func y
  y + yield
end

x = 2

p func(1) { x += 2} # => 5
p x # => 4

# ブロックの外で変数xに2を代入しています。そして、ブロック内でxに2を加算しています。
# 値てはなく変数そのものが共有されていることに注意しなければならない。

# 上の例では、funcメソッドの実行後、xの値を参照すると、値が更新されていることがわかります。
# このような対応づけは、ユーザからは直接指定できず、変更もできないので、代入ではなく束縛と呼ばれます。
# このように処理の生成時の環境を束縛するものを、一般にクロージャと呼びます。
# 遅延評価や高階関数など、様々な用途に使われます。
# 遅延評価とは、処理を実行するタイミングを遅らせることで、効率的な処理を行うことができる手法です。
# 高階関数とは、関数を引数として受け取る関数のことです。

# 特にRubyでは、メソッドの内部から外部の変数を参照できないため、
# クロージャが呼び出し下の変数を処理に持ち込む、数少ない手段の一つであり、より重要です。