# ブロックとProcオブジェクト
# ここまでリテラルを中心にRubyの基本を学んできましたが、Rubyの特徴の一つであるブロックについて学びます。
# まずはブロックとProcで、これは他のプログラミング言語ではクロージャに相当します。


# ブロックの基本
# for,if,whileなどは、スコープが作成されないことを見てきました。
# これに対して、ブロックは新たにスコープを作成するものだと考えてください。
# ブロックはメソッドを呼び出す時のみ記述でき、メソッドの内部では、yieldメソッドを使ってブロックを実行します。

# 使用例
def func
  x + yield # ブロックの実行結果を取得
end

p func(1) { 2 } # => 3: ブロック付きでメソッドを呼び出す

# {} に囲まれているのがブロックです。このブロックは２を返し、メソッドfuncではブロックの実行結果(yield)
# と引数の合計を返しているので、実行結果は３となります。

# ここまではC言語の関数へのポインタのように、単に処理をメソッドに渡しているだけのようにみえる。
# しかしブロックは、さらにスコープを生成するという特徴を持っています。

# スコープが生成されている様子
def func y
  y + yield
end

func(1) do
  x =2
end

p x # => NameError: undefined local variable or method `x' for main:Object

# 上の例では、ブロックの実行中に、ブロックの中で変数xに値を代入しています。
# これは下のスコープ（ブロックの外）とは別の場所に確保されるので、ブロックの外からは参照できません。
# また、ブロックは、波括弧{}だけでなく、do...endでも記述できます。

# ブロックにはもう一つ、重要な特徴があります。
# # 
# ブロックはスコープを生成するのに加えて、ブロック生成時の変数をブロック内で参照することができ、
# その変数を更新すると、結果が外部にも影響します。


# クロージャとしてのブロック
def func y
  y + yield
end

x = 2

p func(1) { x += 2} # => 5
p x # => 4

# ブロックの外で変数xに2を代入しています。そして、ブロック内でxに2を加算しています。
# 値てはなく変数そのものが共有されていることに注意しなければならない。

# 上の例では、funcメソッドの実行後、xの値を参照すると、値が更新されていることがわかります。
# このような対応づけは、ユーザからは直接指定できず、変更もできないので、代入ではなく束縛と呼ばれます。
# このように処理の生成時の環境を束縛するものを、一般にクロージャと呼びます。
# 遅延評価や高階関数など、様々な用途に使われます。
# 遅延評価とは、処理を実行するタイミングを遅らせることで、効率的な処理を行うことができる手法です。
# 高階関数とは、関数を引数として受け取る関数のことです。

# 特にRubyでは、メソッドの内部から外部の変数を参照できないため、
# クロージャが呼び出し下の変数を処理に持ち込む、数少ない手段の一つであり、より重要です。

# ブロックのフォーマットと判定
# ブロックの特徴がわかったので、ブロックの書き方を見ていきましょう。
# ブロックは、引数を受け取ることができ、波括弧{}またはdo...endで囲まれます。
# ブロックの引数は、パイプ(|)で囲まれた変数で受け取ります。

# ブロックの引数の指定
def func a,b
  a + yield(b,3)
end

p func(1,2){|x,y| x + y} # => 6

# ブロックの判定
# ブロック内部で、ブロックが渡されているかどうかを判定する方法です。

def func
  return 1 if block_giben?
  2
end

p func(){} # => 1
p func() # => 2

# ブロックが指定された場合は１を、指定されていない場合は２を返すようにメソッド定義しています。
# これを応用して、ブロックが指定されたときは、それを活用する処理が記述できます。

# Procオブジェクト
# ブロックをオブジェクトとして扱いたい場面が多くあります。このようなときに使用するのがProcオブジェクトです。
# Procは、Procクラスのコンストラクタに,ブロックを指定することで生成できます。
# 実行するには、Procのインスタンスに対してcallメソッドを呼び出します。

# Procの基本
proc = Proc.new{ |x| p x }
proc.call(1) # => 1


# Procオブジェクトの生成
def get_counter start
  Proc.new{|up| start += up} # Procオブジェクト生成。startには現在の値を管理
end

count_up = get_counter(1) # 初期値として１を設定。count_upはProcオブジェクトを参照

count_up.call(1) # => 2 # count_upの参照するブロックを実行

count_up.call(2) # => 4 # count_upの参照するブロックを実行

# ブロックへの変換
def func x 
  x + yield
end

proc = Proc.new{2}

func(1, &proc) # => 3