# 正規表現とコマンド出力

## 正規表現オブジェクトを作成
# 文字列では両端を「'」などで囲みましただ、「/」で囲むと正規表現オブジェクトが生成されます。
# パーセント記法で生成することも可能であり、この場合は「%r」を使います。
# これらの値はRegexpクラスのインスタンスです。

# 正規表現オブジェクトを作成
/Ruby/ # => /Ruby/
%r(Ruby) # => /Ruby/
Regexp.new 'Ruby' # => /Ruby/

# 以上のように生成した正規表現オブジェクトは、さまざまなメソッドを使用することで文字列と比較できます。
# ===演算子から見ていきましょう。この演算子は指定した文字列とマッチしているかどうかを論理値で返します。

## case式と正規表現オブジェクト

/Ruby/ === 'I love Ruby' # => true

p case 'I love Ruby'
when /Ruby/ then; 'Ruby is there!'
when /Java/ then; 'Java is there!'
end # => "Ruby is there!"

# マッチした箇所を取得するには、=~演算子を使用します。
# 正規表現と文字レウtがマッチした場合、=~はマッチした文字列のインデックスを返します。
# マッチしなかった場合はnilを返します。
# =~はStringクラスでも定義されているので、両者を入れ替えても同じ結果となります。

p /Ruby/ =~ 'I love Ruby' # => 7
'I love Ruby' =~ /Ruby/ # => 7

# マッチした文字列を取り出すには、=~演算子と同じスコープで組み込み変数「$&」を参照します。
# マッチした文字列より前の文字列を参照するには「$`」、マッチした文字列より後の文字列を参照するには「$'」を使用します。
# マッチした順に「`&'」となるので、覚え絵置くと便利

# 正規表現の組み込み変数
/bb/ =~ 'aabbcc' # => 2
p $` # => "aa" # マッチした文字列より前の文字列
p $& # => "bb" # マッチした文字列
p $' # => "cc" # マッチした文字列より後の文字列

# ここまで漠然と「マッチした文字列」と説明してきましたが、正確には「マッチした部分文字列」です。
# 上記のように正規表現のパターンを指定すると、それらに対応する箱が順に用意されると考えてください。
# そして、文字列が指定されると、文字列の先頭から順に過去に文字列が送られます。

# 送られてきた文字と箱が一致したら、箱に文字列を入れて閉じ、次の処理をします。
# 一致しない文字列が届いた場合は、全ての箱を空にした上で、次の文字を処理します。
# そして、全て文字の処理が完了したときに、全ての箱が埋まっていればマッチすると判定されます。

