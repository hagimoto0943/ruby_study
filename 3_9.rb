# 正規表現とコマンド出力

## 正規表現オブジェクトを作成
# 文字列では両端を「'」などで囲みましただ、「/」で囲むと正規表現オブジェクトが生成されます。
# パーセント記法で生成することも可能であり、この場合は「%r」を使います。
# これらの値はRegexpクラスのインスタンスです。

# 正規表現オブジェクトを作成
/Ruby/ # => /Ruby/
%r(Ruby) # => /Ruby/
Regexp.new 'Ruby' # => /Ruby/

# 以上のように生成した正規表現オブジェクトは、さまざまなメソッドを使用することで文字列と比較できます。
# ===演算子から見ていきましょう。この演算子は指定した文字列とマッチしているかどうかを論理値で返します。

## case式と正規表現オブジェクト

/Ruby/ === 'I love Ruby' # => true

p case 'I love Ruby'
when /Ruby/ then; 'Ruby is there!'
when /Java/ then; 'Java is there!'
end # => "Ruby is there!"

# マッチした箇所を取得するには、=~演算子を使用します。
# 正規表現と文字レウtがマッチした場合、=~はマッチした文字列のインデックスを返します。
# マッチしなかった場合はnilを返します。
# =~はStringクラスでも定義されているので、両者を入れ替えても同じ結果となります。

p /Ruby/ =~ 'I love Ruby' # => 7
'I love Ruby' =~ /Ruby/ # => 7

# マッチした文字列を取り出すには、=~演算子と同じスコープで組み込み変数「$&」を参照します。
# マッチした文字列より前の文字列を参照するには「$`」、マッチした文字列より後の文字列を参照するには「$'」を使用します。
# マッチした順に「`&'」となるので、覚え絵置くと便利

# 正規表現の組み込み変数
/bb/ =~ 'aabbcc' # => 2
p $` # => "aa" # マッチした文字列より前の文字列
p $& # => "bb" # マッチした文字列
p $' # => "cc" # マッチした文字列より後の文字列

# ここまで漠然と「マッチした文字列」と説明してきましたが、正確には「マッチした部分文字列」です。
# 上記のように正規表現のパターンを指定すると、それらに対応する箱が順に用意されると考えてください。
# そして、文字列が指定されると、文字列の先頭から順に過去に文字列が送られます。

# 送られてきた文字と箱が一致したら、箱に文字列を入れて閉じ、次の処理をします。
# 一致しない文字列が届いた場合は、全ての箱を空にした上で、次の文字を処理します。
# そして、全て文字の処理が完了したときに、全ての箱が埋まっていればマッチすると判定されます。
# /Ruby/ === 'I love Ruby' # => true
# ~~~~~<-この部分が箱で、それぞれの文字が空の状態である
# そこに文字列が送られてきて、一致したら箱に文字列を入れて閉じる

# 行の先頭や末尾は、それらを表現するものが送られてくると考えてください。
# 正規表現のパターンでは、^が行の先頭、$が行の末尾を表します。



reg = /^(aa|bb)c$/
reg === 'aac' # => true
reg === 'bbc' # => true

# このように、正規表現のパターンは、文字列の先頭から順に送られてきた文字列と一致するかどうかを判定します。
# () で囲まれた文字列は、その中の文字列が一致するかどうかを判定します。

# 文字クラス
reg = /a[bcd]e[fg]h/
reg === 'abefh' # => true

# このように、[]で囲まれた文字列は、その中の文字列のいずれかと一致するかどうかを判定します。

# 正規表現記号とオプション

# これまでは、文字クラスにおいて文字を直接入力しましたが、
# 「大文字」や「英数字」といった大きな集合を一つ一つ入力すると日が暮れてしまいます。
# これは「-」を使うことで連続する値を一度に入力できます。

# 文字クラス
/a[1-5]z/ === 'a2z' # => true
/a[b-d]/ === 'abz' # => true

# パターンの中で正規表現記号を指定することで、より簡単に文字の種類を指定できます。

# 正規表現記号一覧
  . # 任意の一文字 (改行文字を除く)
  \d # 任意の数字
  \D # 任意の数字以外
  \w # 任意の英数字
  \W # 任意の英数字以外
  \s # 任意の空白文字
  \S # 任意の空白文字以外
  \b # 単語の境界
  \B # 単語の境界以外
  \A # 文字列の先頭
  \Z # 文字列の末尾
  \z # 文字列の末尾¥
  \G # 前回のマッチの末尾

/a\db/ === 'a2b' # => true

# 次に、繰り返しをカカウ人しましょう。正規表現では、ににの文字に続いて正規表現記号を指定することで、
# その文字の繰り返しを表現できます。

# 繰り返しを表現する正規表現記号
* # 直前の文字の0回以上の繰り返し
+ # 直前の文字の1回以上の繰り返し
{m} # 直前の文字のm回の繰り返し
{m,} # 直前の文字のm回以上の繰り返し
{m,n} # 直前の文字のm回以上n回以下の繰り返し

# 文字の繰り返し
p /a(bc)*d/ === 'ad' # => true
p /a(bc)+d/ === 'abcd' # => true
p /a(bc){2}d/ === 'abcbcd' # => true
p /a(bc){2,}d/ === 'abcbcd' # => true
p /a(bc){1,2}d/ === 'abcd' # => true

# 丸括弧でグループ化した正規h上限にマッチした結果は、特殊変数$1, $2, $3...に格納されます。
# これを正規表現の後方参照と呼びます。
# $1は１番目の正規表現グループにマッチした文字列を保持します。$2,$3...も同様です。
# 対応する正規表現グループがない場合はnilが返ります。

# 正規表現グループ
%r|(http://www(\.)(.*)/)| =~ 'http://www.google.com/'
$1 # => "http://www.google.com/"
$2 # => "." \. はドットを表す . は任意の一文字を表す .だけだと任意の一文字を表す
$3 # => "google.com"
$4 # => nil

# 正規表現オプション
i # 大文字小文字を区別しない
m # 複数行モード
x # 空白文字を無視
o # 正規表現を一度だけ評価

/ruby/ === 'Ruby' # => false
/ruby/i === 'Ruby' # => true
/a.*b/ === "a\nb" # => false
/a.*b/m === "a\nb" # => true

# コマンド出力
バッククォートで囲むことで、コマンドを実行し、その結果を文字列として取得できます。

puts `date + %Y-%m-%d` # => 2021-07-07 # 今日の日付を取得(Mac, Linux), Windowsではdateを使う(以下参考)
puts `date /T` # => 2021-07-07 # 今日の日付を取得(Windows)

# コマンド出力では%xを使うこともできます。バッククォートと同じようにコマンドを実行し、その結果を文字列として取得します。

%x(date + %Y-%m-%d) # => "2021-07-07\n" # 今日の日付を取得(Mac, Linux), Windowsではdateを使う(以下参考)
%x(date /T) # => "2021-07-07\n" # 今日の日付を取得(Windows)

