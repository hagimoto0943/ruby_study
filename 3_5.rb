foo1 = :"foo1"

foo2 = "#{foo1}foo2"

foo3 =  :'foo3'

foo4 = :foo4



p foo1
p foo2
p foo3
p foo4



a = "jfkdjfkljslfunkojdsklfjdklsjflk"
# b[a] = "#{a} %s" % "tinko"

# %s -> symbol
#% -> bouble quote string

a = %
a = %[test]

  # パーセント記法は、文字列リテラルの書式の最後に、パーセント記法を確認しましょう。
  # ここまではダブルクォートやシングルクォートで囲んで文字列を表現してきましたが、パーセント記法では、文字列を囲む記号をプログラマ自身が指定できます。

  "foo" == "foo"
  # => true
  # このコードは、"foo"と"foo"が等しいかどうかを判定しています。この場合、"foo"と"foo"は同じ文字列なので、trueが返ります。

  "foo".equal? "foo"
  # => false
  # 文字列の場合はオブジェクトIDが異なるため、equal?メソッドはfalseを返します。

  :foo == :foo
  # => true 
  :foo.equal? :foo
  # => true
  # シンボルの場合は、オブジェクトIDが同じであるため、===メソッドはtrueを返します。
  "foo".eql? "foo"
  # => true
  1.0 == 1
  # => true
  (1.0).eql? 1
  # => false
  (1.0).eql? 1.0
  # => true
  # eql?メソッドは、オブジェクトの値が等しいかどうかを判定します。オブジェクトのクラスが異なる場合はfalseを返します。eql?メソッドは、==メソッドと違い、オブジェクトのクラス(string,num,floatなど)が異なる場合はfalseを返します。

  def func v1
    v1.object_id
  end

  v1 = "foo1"
  v2 = v1
  p v1.chop!
  p v2
  p v1.chop!
  p v2

  # chop!メソッドは、文字列の最後の文字を削除します。chop!メソッドは破壊的メソッドなので、呼び出し元の文字列が変更されます。よって、v2も変更されます。
  # !がついているメソッドは破壊的メソッドであることが多いです。破壊的メソッドは、呼び出し元のオブジェクトを変更します。破壊的メソッドは、メソッド名の最後に!がついています。

  v1 = "foo"
  v2 = "foo"
  v3 = "foo"

  p v1.object_id

  # まとめると文字列とシンボルの違いは以下の通りです。
  # 文字列は、同じ文字列であっても、オブジェクトIDが異なるため、equal?メソッドはfalseを返します。
  # シンボルは、同じシンボルであれば、オブジェクトIDが同じため、equal?メソッドはtrueを返します。

  # - シンボルは書き換えられない
  # - シンボルは同値ならば必ず同一
  # - 比較の処理はシンボルの方が高速

  シンボルの実装と用途
そしてその整数をRubyのコード上で表現したものがシンボルです.
シンボルは、ソース上では文字列のように見え、内部では整数として扱われる、両者を仲立ちするような存在です.
名前を管理するという役割上、シンボルと文字列は一対一に対応します.